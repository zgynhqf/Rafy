<html><head><meta http-equiv="X-UA-Compatible" content="IE=edge" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" type="text/css" href="../styles/branding.css" /><link rel="stylesheet" type="text/css" href="../styles/branding-zh-CN.css" /><script type="text/javascript" src="../scripts/branding.js"> </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>继承映射</title><meta name="Language" content="zh-cn" /><meta name="Microsoft.Help.Id" content="8b3a3b78-9e6a-4558-938d-7692ae6aaa8f" /><meta name="Description" content="在 ORM 框架中，领域实体与数据表的映射往往是一对一的。但是面向对象的特性之一是支持继承，继承不但可以支持代码重用，更是另一特性多态的基础。所以支持继承的映射，对于面向对象的实体设计来说，是非常必要的。" /><meta name="Microsoft.Help.ContentType" content="Concepts" /><meta name="BrandingAware" content="true" /><link type="text/css" rel="stylesheet" href="../styles/highlight.css" /><script type="text/javascript" src="../scripts/highlight.js"> </script><link rel="stylesheet" type="text/css" href="../styles/branding-Website.css" /><script type="text/javascript" src="../scripts/jquery-1.11.0.min.js"></script><script type="text/javascript" src="../scripts/branding-Website.js"></script></head><body onload="OnLoad('cs')"><input type="hidden" id="userDataCache" class="userDataStyle" /><div class="pageHeader" id="PageHeader">Rafy User Guide<form id="SearchForm" method="get" action="#" onsubmit="javascript:TransferToSearchPage(); return false;"><input id="SearchTextBox" type="text" maxlength="200" /><button id="SearchButton" type="submit"></button></form></div><div class="pageBody"><div class="leftNav" id="leftNav"><div id="tocNav"><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="69b641cf-d1fe-4f06-877f-b479d268a3fc.htm" title="Rafy User Guide" tocid="roottoc">Rafy User Guide</a></div><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="69b641cf-d1fe-4f06-877f-b479d268a3fc.htm" title="Rafy框架" tocid="69b641cf-d1fe-4f06-877f-b479d268a3fc">Rafy框架</a></div><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="c8e6cd25-c674-4cd1-9880-816d11f58eb8.htm" title="领域实体框架" tocid="c8e6cd25-c674-4cd1-9880-816d11f58eb8">领域实体框架</a></div><div class="toclevel1" data-toclevel="1" data-childrenloaded="true"><a class="tocExpanded" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="0f6e3552-029f-4a32-9655-e4b6fb22edcc.htm" title="对象关系映射" tocid="0f6e3552-029f-4a32-9655-e4b6fb22edcc">对象关系映射</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="eba03db2-2a71-4499-9dcd-99e0c37fe10e.htm" title="配置映射" tocid="eba03db2-2a71-4499-9dcd-99e0c37fe10e">配置映射</a></div><div class="toclevel2 current" data-toclevel="2"><a data-tochassubtree="false" href="8b3a3b78-9e6a-4558-938d-7692ae6aaa8f.htm" title="继承映射" tocid="8b3a3b78-9e6a-4558-938d-7692ae6aaa8f">继承映射</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="12520633-1fbf-45dc-aca8-c4089b5c90e0.htm" title="SQL 语句日志" tocid="12520633-1fbf-45dc-aca8-c4089b5c90e0">SQL 语句日志</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="b40cd779-ec8a-469d-82f5-bd99128561c4.htm" title="数据库同步功能" tocid="b40cd779-ec8a-469d-82f5-bd99128561c4">数据库同步功能</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="ef53c777-dd02-4a01-98c9-7dcc49489cec.htm" title="多数据库支持" tocid="ef53c777-dd02-4a01-98c9-7dcc49489cec">多数据库支持</a></div></div><div id="tocResizableEW" onmousedown="OnMouseDown(event);"></div><div id="TocResize" class="tocResize"><img id="ResizeImageIncrease" src="../icons/TocOpen.gif" onclick="OnIncreaseToc()" alt="Click or drag to resize" title="Click or drag to resize" /><img id="ResizeImageReset" src="../icons/TocClose.gif" style="display:none" onclick="OnResetToc()" alt="Click or drag to resize" title="Click or drag to resize" /></div></div><div class="topicContent" id="TopicContent"><table class="titleTable"><tr><td class="titleColumn">继承映射</td></tr></table><span class="introStyle"></span><div class="introduction"><p>This topic contains the following sections:</p><ul class="autoOutline"><li class="outlineSectionEntry"><a href="#Summary">概念</a></li><li class="outlineSectionEntry"><a href="#inh">Rafy 实体继承</a></li><li class="outlineSectionEntry"><a href="#TPC">TPC 配置</a></li><li class="outlineSectionEntry"><a href="#TPH">TPH 配置</a></li><li class="outlineSectionEntry"><a href="#notice">注意</a></li></ul></div><div class="collapsibleAreaRegion" id="Summary"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID0RB')" onkeypress="SectionExpandCollapse_CheckKey('ID0RB', event)" tabindex="0"><img id="ID0RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />概念</span></div><div id="ID0RBSection" class="collapsibleSection"><p>在 ORM 框架中，领域实体与数据表的映射往往是一对一的。但是面向对象的特性之一是支持继承，继承不但可以支持代码重用，更是另一特性多态的基础。所以支持继承的映射，对于面向对象的实体设计来说，是非常必要的。</p><p>一般而言，拥有继承关系的几个实体类，映射到数据库表的方式有以下三种：</p><ul><li><p>Table Per Hierarchy (TPH)：整个继承树中的所有实体都映射同一张表。</p></li><li><p>Table Per Type (TPT)：继承树中的包括父类与子类在内的每一个类型都映射一张单独的表。</p></li><li><p>Table Per Concrete Class (TPC)：继承树中叶子结点上的具体子类型才映射单独的数据表。</p></li></ul><p>
                    关于这三种映射方式的具体介绍，网上比较多。以下是 MS ADO.NET 团队博客中的文章，可以从中详细了解：《<a href="http://blogs.msdn.com/b/adonet/archive/2010/10/26/10080555.aspx" target="_blank">Inheritance Mapping</a>》
                </p></div><div class="collapsibleAreaRegion" id="inh"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID1RB')" onkeypress="SectionExpandCollapse_CheckKey('ID1RB', event)" tabindex="0"><img id="ID1RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Rafy 实体继承</span></div><div id="ID1RBSection" class="collapsibleSection"><p>
                    目前框架中只支持 TPC、TPH 两种模式，不支持 TPT。而且建议使用 TPC 映射。接下来，使用以下模型作为示例：
                </p><div class="mediaNear"><div class="caption">领域模型</div><img alt="Entity Demo" src="../media/EntityDemo.jpeg" /></div></div><div class="collapsibleAreaRegion" id="TPC"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID3RB')" onkeypress="SectionExpandCollapse_CheckKey('ID3RB', event)" tabindex="0"><img id="ID3RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />TPC 配置</span></div><div id="ID3RBSection" class="collapsibleSection"><p>
                    优点：
                    简单。建议使用。
                </p><p>
                    缺点：
                    当需要对基类统一查询时，较为麻烦，需要使用手动 SQL 完成。
                    数据库中没有外键约束，需要使用代码同步。
                </p><p>
                    配置方法：
                    把基类 StorageIn 设置为 abstract 类，则基类不会生成表。
                    同时两个子类 OrderStorageIn 和 OtherStorageIn 分别设置为映射所有字段。这时，由于它们继承了基类的所有属性，所以它们分别生成了它们自己的表。
                    同时，StorageInItem 的外键则完全失效，也不会自动的级联删除。如图：
                </p><div class="mediaNear"><div class="caption">TPC 表结构</div><img alt="无关表" src="../media/无关表.jpeg" /></div><p>这时，我们需要在代码中主动添加级联删除，如 StorageIn 的 OnDelete 方法中加入以下代码：</p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID2EAAADAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID2EAAADAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID2EAAADAAA');return false;" title="Copy">Copy</a></div></div><div id="ID2EAAADAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">protected</span> <span class="highlight-keyword">override</span> <span class="highlight-keyword">void</span> OnDelete()
{
    <span class="highlight-keyword">base</span>.OnDelete();

    <span class="highlight-comment">//由于本类没有映射数据表，所以在删除的时候需要删除下面的数据</span>
    <span class="highlight-keyword">using</span> (<span class="highlight-keyword">var</span> db = <span class="highlight-keyword">this</span>.CreateDb())
    {
        db.Delete(<span class="highlight-keyword">typeof</span>(StorageInBillItem), db.Query(<span class="highlight-keyword">typeof</span>(StorageInBillItem))
            .Constrain(StorageInBillItem.StorageInBillRefProperty).Equal(<span class="highlight-keyword">this</span>.Id)
            );
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID2EAAADAAA");</script></div><div class="collapsibleAreaRegion" id="TPH"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID4RB')" onkeypress="SectionExpandCollapse_CheckKey('ID4RB', event)" tabindex="0"><img id="ID4RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />TPH 配置</span></div><div id="ID4RBSection" class="collapsibleSection"><p>
                    优点：
                    对基类进行统一的查询时较为方便。
                </p><p>
                    缺点：
                    要为所有子类的查询都添加分辨类型字段的过滤。
                </p><p>
                    配置方法：
                    首先，StorageIn 不设置为抽象类，
                    同时两个子类 OrderStorageIn 和 OtherStorageIn 分别设置为映射所有字段，并显式指定映射到基类的表上，即：
                    Meta.MapTable("StorageIn").MapAllPropertiesToTable();

                    这时，生成表如下：
                </p><div class="mediaNear"><div class="caption">TPH 表结构</div><img alt="TPH" src="../media/TPH.jpeg" /></div><p>
                    外键及所对应的级联删除都存在，比较简单。

                    这样，包括两个子类的所有的字段都存放在基类的表 StorageIn 中。也就是说，这种模式下，需要两个子类添加的新字段都是可以为空的，否则会造成其它的类型无法插入。
                    同时，由于两个类的数据都存储在同一张表里，所以数据需要添加一个单独的字段进行分辨，例如：在 StorageIn 上添加属性 Descrimilator，然后，在子类中分别为该属性设置不同的默认值：
                </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID2EAEACAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID2EAEACAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID2EAEACAAA');return false;" title="Copy">Copy</a></div></div><div id="ID2EAEACAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve">[RootEntity, Serializable]
<span class="highlight-keyword">public</span> <span class="highlight-keyword">class</span> OtherStorageIn : StorageIn
{
    <span class="highlight-keyword">public</span> <span class="highlight-keyword">static</span> <span class="highlight-keyword">readonly</span> <span class="highlight-keyword">string</span> DescriminatorName;

    <span class="highlight-keyword">static</span> OtherStorageIn()
    {
        DescriminatorName = <span class="highlight-literal">"OtherStorageIn"</span>;
        DescriminatorProperty.OverrideMeta(<span class="highlight-keyword">typeof</span>(OtherStorageIn), <span class="highlight-keyword">new</span> ManagedPropertyMetadata&lt;<span class="highlight-keyword">string</span>&gt;
        {
            DefaultValue = DescriminatorName
        });
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID2EAEACAAA");</script><p>
                    以及：
                </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID2EACACAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID2EACACAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID2EACACAAA');return false;" title="Copy">Copy</a></div></div><div id="ID2EACACAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve">[RootEntity, Serializable]
<span class="highlight-keyword">public</span> <span class="highlight-keyword">class</span> OrderStorageIn : StorageIn
{
    <span class="highlight-keyword">public</span> <span class="highlight-keyword">static</span> <span class="highlight-keyword">readonly</span> <span class="highlight-keyword">string</span> DescriminatorName;

    <span class="highlight-keyword">static</span> OrderStorageIn()
    {
        DescriminatorName = <span class="highlight-literal">"OrderStorageIn"</span>;
        DescriminatorProperty.OverrideMeta(<span class="highlight-keyword">typeof</span>(OrderStorageIn), <span class="highlight-keyword">new</span> ManagedPropertyMetadata&lt;<span class="highlight-keyword">string</span>&gt;
        {
            DefaultValue = DescriminatorName
        });
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID2EACACAAA");</script><p>
                    这样，这两个子类存储在数据库中的数据的该字段就分别有了不同的值。然后在查询时，分别对该字段进行过滤即可，例如：
                </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID2EAAACAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID2EAAACAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID2EAAACAAA');return false;" title="Copy">Copy</a></div></div><div id="ID2EAAACAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve">[Serializable]
<span class="highlight-keyword">public</span> <span class="highlight-keyword">class</span> OrderStorageInList : StorageInList
{
    <span class="highlight-keyword">protected</span> <span class="highlight-keyword">override</span> <span class="highlight-keyword">void</span> OnGetAll()
    {
        <span class="highlight-keyword">this</span>.QueryDb(q =&gt; q.Constrain(StorageIn.DescriminatorProperty).Equal(OrderStorageIn.DescriminatorName));
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID2EAAACAAA");</script></div><div class="collapsibleAreaRegion" id="notice"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID5RB')" onkeypress="SectionExpandCollapse_CheckKey('ID5RB', event)" tabindex="0"><img id="ID5RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />注意</span></div><div id="ID5RBSection" class="collapsibleSection"><ul><li><p>继承后，只支持直接对具体的子类的查询，不支持对抽象父类的查询。也就是说，不支持查询出一个父类的实体列表，列表中的元素，一部分是子类 A 的对象，另一部分则是子类 B 的对象。</p></li><li><p>子实体继承了父实体后，其对应的子实体集合、子实体仓库也必须从父实体集合及父实体仓库继承。</p></li></ul></div></div></div><div id="pageFooter" class="pageFooter">胡庆访 @版权所有，有问题请联系 9474649@qq.com。<div class="feedbackLink">有关这个主题的评论请发邮件到
        <a id="HT_MailLink" href="mailto:9474649%40qq.com?Subject=Rafy User Guide">发送反馈</a></div><script type="text/javascript">
        var HT_mailLink = document.getElementById("HT_MailLink");
        var HT_mailLinkText = HT_mailLink.innerHTML;
        HT_mailLink.href += ": " + document.title + "\u0026body=" + encodeURIComponent("Your feedback is used to improve the documentation and the product. Your e-mail address will not be used for any other purpose and is disposed of after the issue you report is resolved. While working to resolve the issue that you report, you may be contacted via e-mail to get further details or clarification on the feedback you sent. After the issue you report has been addressed, you may receive an e-mail to let you know that your feedback has been addressed.");
        HT_mailLink.innerHTML = HT_mailLinkText;
        </script></div></body></html>